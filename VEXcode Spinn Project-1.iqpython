{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\nimport math\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nbrain_inertial = Inertial()\nmotor_5 = Motor(Ports.PORT5, False)\ndistance_6 = Distance(Ports.PORT6)\noptical_1 = Optical(Ports.PORT1)\n\n\n\n# generating and setting random seed\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    xaxis = brain_inertial.acceleration(XAXIS) * 1000\n    yaxis = brain_inertial.acceleration(YAXIS) * 1000\n    zaxis = brain_inertial.acceleration(ZAXIS) * 1000\n    systemTime = brain.timer.system() * 100\n    urandom.seed(int(xaxis + yaxis + zaxis + systemTime)) \n    \n# Initialize random seed \ninitializeRandomSeed()\n\n\n# Color to String Helper\ndef convert_color_to_string(col):\n    if col == Color.RED:\n        return \"red\"\n    if col == Color.GREEN:\n        return \"green\"\n    if col == Color.BLUE:\n        return \"blue\"\n    if col == Color.WHITE:\n        return \"white\"\n    if col == Color.YELLOW:\n        return \"yellow\"\n    if col == Color.ORANGE:\n        return \"orange\"\n    if col == Color.PURPLE:\n        return \"purple\"\n    if col == Color.CYAN:\n        return \"cyan\"\n    if col == Color.RED_VIOLET:\n        return \"red_violet\"\n    if col == Color.VIOLET:\n        return \"violet\"\n    if col == Color.BLUE_VIOLET:\n        return \"blue_violet\"\n    if col == Color.BLUE_GREEN:\n        return \"blue_green\"\n    if col == Color.YELLOW_GREEN:\n        return \"yellow_green\"\n    if col == Color.YELLOW_ORANGE:\n        return \"yellow_orange\"\n    if col == Color.RED_ORANGE:\n        return \"red_orange\"\n    if col == Color.BLACK:\n        return \"black\"\n    if col == Color.TRANSPARENT:\n        return \"transparent\"\n    return \"\"\n\n#endregion VEXcode Generated Robot Configuration\n\nscreen_precision = 0\nconsole_precision = 0\nscreen_width = 160 #x-y units\nscreen_height = 108\ntheta = 18 # number in degrees\narm_radius = 127 # mm\nmyVariable = 0\ni = 0\ndistance_vals = [0 for x in range(20)]\nangle_dist_record = [0 for x in range(20)] # in rads for trig funcs\nlens = [0 for x in range(20)]\ncolor_vals = [0 for x in range(20)]\nrect_coords = [0 for x in range(20)]\ncorrected_coords = [0 for x in range(20)]\nscaled_coords = []\nold_min_x, old_max_x, old_min_y, old_max_y = (1000, -1000, 1000, -1000)\n\ndef avg(vals):\n    retSum = 0\n    for i in vals:\n        retSum += i\n    return retSum/len(vals)\n\ndef convert_hue_to_color():\n    global avg_color, color_vals\n    avg_color = avg(color_vals)\n    # hue_normal = avg_color / 60 # convert to color parts\n    if (avg_color > 300 or avg_color < 30):\n        return Color.RED\n    if (avg_color > 30 and avg_color < 75):\n        return Color.YELLOW\n    if (avg_color > 75 and avg_color < 140):\n        return Color.GREEN\n    if (avg_color > 140 and avg_color < 210):\n        return Color.CYAN\n    if (avg_color > 210 and avg_color < 300):\n        return Color.BLUE\n\ndef subtractive_coords():\n    global lens, distance_vals, arm_radius\n    for x in range(len(distance_vals)):\n        lens[x] = arm_radius - distance_vals[x]\n\ndef polar_rect_coord_conv():\n    global lens, theta, rect_coords, angle_dist_record, corrected_coords, scaled_coords, old_min_x, old_max_x, old_min_y, old_max_y\n    # polar to rectangular conversion\n    for i in range(len(lens)):\n        rect_coords[i] = ((lens[i] * math.cos(angle_dist_record[i])), (lens[i] * math.sin(angle_dist_record[i])))\n    # calculate centroid\n    x_avg = 0\n    y_avg = 0\n    for i in range(len(rect_coords)):\n        x_avg = x_avg + rect_coords[i][0]\n        y_avg = y_avg + rect_coords[i][1]\n    x_avg = x_avg / len(rect_coords)\n    y_avg = y_avg / len(rect_coords)\n    # data_print([x_avg, y_avg], 5)\n\n    # align centroid with screen center\n    for i in range(len(corrected_coords)):\n        corrected_coords[i] = (rect_coords[i][0] - x_avg + (screen_width/2), rect_coords[i][1] - y_avg + (screen_height/2))\n    \n    old_min_x, old_max_x, old_min_y, old_max_y = (1000, -1000, 1000, -1000)\n    for j in range(len(corrected_coords)):\n        if corrected_coords[j][0] < old_min_x:\n            old_min_x = corrected_coords[j][0]\n        if corrected_coords[j][0] > old_max_x:\n            old_max_x = corrected_coords[j][0]\n        if corrected_coords[j][1] < old_min_y:\n            old_min_y = corrected_coords[j][1]\n        if corrected_coords[j][1] > old_max_y:\n            old_max_y = corrected_coords[j][1]\n    new_min_x = 0\n    new_max_x = 160\n    new_min_y = 0\n    new_max_y = 108\n\n    old_range_x = old_max_x - old_min_x\n    old_range_y = old_max_y - old_min_y\n    new_range_x = 160\n    new_range_y = 108\n\n    scale_factor_x = new_range_x / old_range_x\n    scale_factor_y = new_range_y / old_range_y\n    # data_print([scale_factor_x, scale_factor_y], 5)\n    uniform_scale = min(scale_factor_x, scale_factor_y)\n\n    for x, y in corrected_coords:\n        # new_x = 0\n        # new_y = 0\n        if old_range_x == 0 or old_range_y == 0:\n            new_x = (new_min_x + new_max_x)/2\n            new_y = (new_min_y + new_max_y)/2\n        else:\n            new_x = ((x - old_min_x) * uniform_scale) + new_min_x\n            new_y = ((y - old_min_y) * uniform_scale) + new_min_y\n            # data_print(scaled_coords)\n        scaled_coords.append((new_x, new_y))\n    # data_print(scaled_coords, 5)\n    \ndef print_shape():\n    global scaled_coords\n    # data_print(scaled_coords, 5)\n    avg_color = avg(color_vals)\n    obj_color = convert_hue_to_color()\n    brain.screen.set_pen_width(3)\n    brain.screen.set_pen_color(Color.WHITE)\n    brain.screen.clear_screen()\n    for x in range(len(scaled_coords)):\n        if x == len(scaled_coords) - 1:\n            brain.screen.draw_line(scaled_coords[x][0], scaled_coords[x][1], scaled_coords[0][0], scaled_coords[0][1])\n        else:\n            brain.screen.draw_line(scaled_coords[x][0], scaled_coords[x][1], scaled_coords[x+1][0], scaled_coords[x+1][1])\n    scanline_poly_fill(scaled_coords, obj_color)\n    timer(5)\n    brain.screen.set_pen_width(1)\n    blank_screen()\n\ndef blank_screen():\n    brain.screen.set_pen_color(Color.BLACK)\n    for i in range(screen_width):\n        for j in range(screen_height):\n            brain.screen.draw_pixel(i, j)\n    brain.screen.set_pen_color(Color.WHITE)\n\ndef scanline_poly_fill(points, color):\n    if not points:\n        return\n    min_y = int(min(p[1] for p in points))\n    max_y = int(max(p[1] for p in points))\n    closed_points = points + [points[0]]\n    for y in range(min_y, max_y + 1):\n        intersections = []\n        for i in range(len(points)):\n            p1 = closed_points[i]\n            p2 = closed_points[i+1]\n            y1, y2 = p1[1], p2[1]\n            x1, x2 = p1[0], p2[0]\n            if (y1 <= y < y2) or (y2 <= y < y1):\n                if y1 != y2:\n                    x_intersect = x1 + (y - y1) * (x2 - x1) / (y2 - y1)\n                    intersections.append(int(round(x_intersect)))\n        intersections.sort()\n        brain.screen.set_pen_color(color)\n        for i in range(0, len(intersections) - 1, 2):\n            x_start = intersections[i]\n            x_end = intersections[i+1]\n            brain.screen.draw_line(x_start, y, x_end, y)\n    brain.screen.set_pen_color(Color.WHITE)\n\ndef data_print(list_of_data, timer_len):\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1,1)\n    if any(isinstance(item, tuple) for item in list_of_data):\n        for tuple_item in list_of_data:\n            if brain.screen.row() == 5:\n                timer(timer_len)\n                brain.screen.clear_screen()\n                brain.screen.set_cursor(1,1)\n            brain.screen.print(tuple_item)\n            brain.screen.next_row()\n    else:\n        brain.screen.print(list_of_data)\n        brain.screen.next_row()\n        timer(timer_len)\n    brain.screen.print(\"Please wait...\")\n    brain.screen.next_row()\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1,1)\n\ndef timer(timer_len):\n    brain.timer.clear()\n    for count in range(timer_len):\n        brain.screen.clear_row(5)\n        brain.screen.set_cursor(5,1)\n        brain.screen.print(str(math.ceil(timer_len - brain.timer.time(SECONDS))) + \"(s)\")\n        brain.screen.set_cursor(5, 8)\n        brain.screen.print(\"(>) Exit\")\n        wait(1, SECONDS)\n        brain.screen.set_cursor(5, 1)\n        if (brain.buttonRight.pressing()):\n            break\n\ndef menu():\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1,1)\n    brain.screen.print(\"(<) Return Arm Pos\")\n    brain.screen.next_row()\n    brain.screen.print(\"(>) Run Program\")\n\ndef wait_screen():\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1,1)\n    brain.screen.print(\"Scanning...\")\n    brain.screen.next_row()\n    brain.screen.print(\"Please wait\")\n\ndef test():\n    global screen_precision, console_precision, screen_width, screen_height, theta, arm_radius, myVariable, i, distance_vals, angle_dist_record, lens, color_vals, rect_coords, corrected_coords, scaled_coords\n    init_arm_pos = motor_5.position(DEGREES)\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1,1)\n    menu()\n    while True:\n        if brain.buttonLeft.pressing():\n            if motor_5.position(DEGREES) != init_arm_pos:\n                motor_5.spin_to_position(init_arm_pos, DEGREES)\n            menu()\n        if brain.buttonRight.pressing():\n            wait_screen()\n            if motor_5.position(DEGREES) != init_arm_pos:\n                motor_5.spin_to_position(init_arm_pos, DEGREES)\n            distance_vals = [0 for x in range(20)]\n            angle_dist_record = [0 for x in range(20)] # in rads for trig funcs\n            lens = [0 for x in range(20)]\n            color_vals = [0 for x in range(20)]\n            rect_coords = [0 for x in range(20)]\n            corrected_coords = [0 for x in range(20)]\n            scaled_coords = []\n            distance_vals = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n            angle_dist_record = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n            color_vals = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n            lens = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\n\n            avg_color = optical_1.hue()\n            i = 0\n            for repeat_count in range(int(len(color_vals))):\n                optical_1.set_light_power(150,PERCENT)\n                optical_1.set_light(LedStateType.ON)\n                motor_5.spin_for(FORWARD, theta, DEGREES)\n                distance_vals[i] = distance_6.object_distance(MM)\n                color_vals[i] = optical_1.hue()\n                angle_dist_record[i] = motor_5.position(DEGREES) * (math.pi / 180) # radian conversion\n                i += 1\n                wait(20, MSEC)\n            i = 0\n            subtractive_coords()\n            polar_rect_coord_conv()\n            print_shape()\n            menu()\n            \n        wait(20, MSEC)\n\ndef spin_program():\n    pass\n\ndef when_started1():\n    test()\n\nwhen_started1()\n","textLanguage":"python","robotConfig":[{"port":[5],"name":"motor_5","customName":false,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"distance_6","customName":false,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[1],"name":"optical_1","customName":false,"deviceType":"Optical","deviceClass":"optical","setting":{},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20230818.11.00.00","appVersion":"4.62.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"Second","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"target":"Physical"}